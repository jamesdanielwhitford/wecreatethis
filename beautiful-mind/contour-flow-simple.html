<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contour Flow Pattern</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }
        #text-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            font-weight: bold;
            font-family: Arial, sans-serif;
            color: #ff0000;
            pointer-events: none;
            z-index: 5;
            text-align: center;
            max-width: 90%;
        }
        #controls {
            position: fixed;
            top: 0;
            right: 0;
            background-color: rgba(240, 240, 240, 0.95);
            color: #000;
            padding: 20px;
            border-radius: 0 0 0 10px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 15px;
            transition: transform 0.3s ease;
            transform: translateY(-100%);
            min-width: 300px;
        }
        #controls:hover {
            transform: translateY(0);
        }
        #controls::after {
            content: 'âš™';
            position: absolute;
            top: 100%;
            right: 20px;
            background-color: rgba(240, 240, 240, 0.95);
            padding: 5px 15px;
            border-radius: 0 0 10px 10px;
            font-size: 20px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        label {
            font-size: 14px;
            font-weight: bold;
        }
        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            background: #ddd;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #000;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #000;
            cursor: pointer;
            border: none;
        }
        .value-display {
            font-size: 14px;
            font-weight: bold;
            min-width: 40px;
            text-align: right;
        }
        button {
            background-color: #000;
            color: white;
            border: 2px solid #000;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
        }
        button:hover {
            background-color: #333;
        }
        .color-picker-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="color"] {
            width: 50px;
            height: 35px;
            border: 2px solid #000;
            border-radius: 5px;
            cursor: pointer;
        }
        input[type="text"] {
            padding: 8px;
            border: 2px solid #000;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            width: 100%;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="text-overlay">SAMPLE TEXT</div>

    <div id="controls">
        <div class="control-group">
            <label>Contour Lines:</label>
            <div class="slider-row">
                <input type="range" id="contour-count" min="5" max="50" value="20" step="1">
                <span class="value-display" id="contour-value">20</span>
            </div>
        </div>

        <div class="control-group">
            <label>Line Thickness:</label>
            <div class="slider-row">
                <input type="range" id="line-thickness" min="0" max="10" value="2" step="1">
                <span class="value-display" id="thickness-value">2</span>
            </div>
        </div>

        <div class="control-group">
            <label>Flow Scale:</label>
            <div class="slider-row">
                <input type="range" id="flow-scale" min="50" max="400" value="150" step="10">
                <span class="value-display" id="scale-value">150</span>
            </div>
        </div>

        <div class="control-group">
            <label>Turbulence:</label>
            <div class="slider-row">
                <input type="range" id="turbulence" min="1" max="10" value="5" step="1">
                <span class="value-display" id="turb-value">5</span>
            </div>
        </div>

        <div class="control-group">
            <label>Background Color:</label>
            <div class="color-picker-row">
                <input type="color" id="bg-color" value="#ffffff">
            </div>
        </div>

        <div class="control-group">
            <label>Line Color:</label>
            <div class="color-picker-row">
                <input type="color" id="line-color" value="#000000">
            </div>
        </div>

        <div class="control-group">
            <label>Text Color:</label>
            <div class="color-picker-row">
                <input type="color" id="text-color" value="#ff0000">
            </div>
        </div>

        <div class="control-group">
            <label>Text:</label>
            <input type="text" id="text-input" value="SAMPLE TEXT">
        </div>

        <button onclick="regenerate()">Regenerate</button>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const textOverlay = document.getElementById('text-overlay');

        const contourCountSlider = document.getElementById('contour-count');
        const lineThicknessSlider = document.getElementById('line-thickness');
        const flowScaleSlider = document.getElementById('flow-scale');
        const turbulenceSlider = document.getElementById('turbulence');
        const bgColorPicker = document.getElementById('bg-color');
        const lineColorPicker = document.getElementById('line-color');
        const textColorPicker = document.getElementById('text-color');
        const textInput = document.getElementById('text-input');

        const contourValue = document.getElementById('contour-value');
        const thicknessValue = document.getElementById('thickness-value');
        const scaleValue = document.getElementById('scale-value');
        const turbValue = document.getElementById('turb-value');

        let contourCount = 20;
        let lineThickness = 2;
        let flowScale = 150;
        let turbulence = 5;
        let bgColor = '#ffffff';
        let lineColor = '#000000';
        let offsetX = 0;
        let offsetY = 0;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        resizeCanvas();

        // Perlin-like noise functions
        function random2D(x, y) {
            const n = Math.sin(x * 12.9898 + y * 78.233 + offsetX) * 43758.5453;
            return n - Math.floor(n);
        }

        function noise(x, y) {
            const i = Math.floor(x);
            const j = Math.floor(y);
            const f = x - i;
            const g = y - j;

            const a = random2D(i, j);
            const b = random2D(i + 1, j);
            const c = random2D(i, j + 1);
            const d = random2D(i + 1, j + 1);

            const u = f * f * (3 - 2 * f);
            const v = g * g * (3 - 2 * g);

            return a * (1 - u) * (1 - v) +
                   b * u * (1 - v) +
                   c * (1 - u) * v +
                   d * u * v;
        }

        function fbm(x, y, octaves) {
            let value = 0;
            let amplitude = 0.5;
            let frequency = 1;

            for (let i = 0; i < octaves; i++) {
                value += amplitude * noise(x * frequency, y * frequency);
                frequency *= 2;
                amplitude *= 0.5;
            }

            return value;
        }

        function getHeight(x, y) {
            const baseNoise = fbm(x / flowScale, y / flowScale, turbulence);

            // Add some warping for more interesting shapes
            const warpX = fbm((x + 100) / (flowScale * 0.5), y / (flowScale * 0.5), 3) * 50;
            const warpY = fbm(x / (flowScale * 0.5), (y + 100) / (flowScale * 0.5), 3) * 50;

            const warpedNoise = fbm((x + warpX) / flowScale, (y + warpY) / flowScale, turbulence);

            return (baseNoise + warpedNoise * 0.5) * 0.5;
        }

        function regenerate() {
            offsetX = Math.random() * 10000;
            offsetY = Math.random() * 10000;
            draw();
        }

        function draw() {
            // Calculate height map
            const resolution = 2;
            const width = Math.ceil(canvas.width / resolution);
            const height = Math.ceil(canvas.height / resolution);
            const heightMap = [];

            for (let y = 0; y < height; y++) {
                heightMap[y] = [];
                for (let x = 0; x < width; x++) {
                    heightMap[y][x] = getHeight(x * resolution, y * resolution);
                }
            }

            // Find min and max for normalization
            let min = Infinity, max = -Infinity;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    min = Math.min(min, heightMap[y][x]);
                    max = Math.max(max, heightMap[y][x]);
                }
            }

            // Normalize height map
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    heightMap[y][x] = (heightMap[y][x] - min) / (max - min);
                }
            }

            // Create image data for filled contours
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            const data = imageData.data;

            // Parse colors
            const bgColorRGB = hexToRgb(bgColor);
            const lineColorRGB = hexToRgb(lineColor);

            // Fill each pixel based on which contour band it falls in
            for (let py = 0; py < canvas.height; py++) {
                for (let px = 0; px < canvas.width; px++) {
                    const hx = Math.floor(px / resolution);
                    const hy = Math.floor(py / resolution);

                    if (hx < width && hy < height) {
                        const heightValue = heightMap[hy][hx];
                        const band = Math.floor(heightValue * contourCount);

                        // Alternate colors for each band
                        const idx = (py * canvas.width + px) * 4;
                        if (band % 2 === 0) {
                            data[idx] = bgColorRGB.r;
                            data[idx + 1] = bgColorRGB.g;
                            data[idx + 2] = bgColorRGB.b;
                        } else {
                            data[idx] = lineColorRGB.r;
                            data[idx + 1] = lineColorRGB.g;
                            data[idx + 2] = lineColorRGB.b;
                        }
                        data[idx + 3] = 255;
                    }
                }
            }

            ctx.putImageData(imageData, 0, 0);

            // Optionally draw outlines for definition
            if (lineThickness > 0) {
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = Math.max(1, lineThickness * 0.5);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Draw contour lines
                for (let level = 0; level <= contourCount; level++) {
                    const threshold = level / contourCount;

                    ctx.beginPath();

                    for (let y = 0; y < height - 1; y++) {
                        for (let x = 0; x < width - 1; x++) {
                            const h00 = heightMap[y][x];
                            const h10 = heightMap[y][x + 1];
                            const h01 = heightMap[y + 1][x];
                            const h11 = heightMap[y + 1][x + 1];

                            const points = [];

                            // Check edges for threshold crossings
                            if ((h00 < threshold && h10 >= threshold) || (h00 >= threshold && h10 < threshold)) {
                                const t = (threshold - h00) / (h10 - h00);
                                points.push({
                                    x: (x + t) * resolution,
                                    y: y * resolution
                                });
                            }

                            if ((h10 < threshold && h11 >= threshold) || (h10 >= threshold && h11 < threshold)) {
                                const t = (threshold - h10) / (h11 - h10);
                                points.push({
                                    x: (x + 1) * resolution,
                                    y: (y + t) * resolution
                                });
                            }

                            if ((h01 < threshold && h11 >= threshold) || (h01 >= threshold && h11 < threshold)) {
                                const t = (threshold - h01) / (h11 - h01);
                                points.push({
                                    x: (x + t) * resolution,
                                    y: (y + 1) * resolution
                                });
                            }

                            if ((h00 < threshold && h01 >= threshold) || (h00 >= threshold && h01 < threshold)) {
                                const t = (threshold - h00) / (h01 - h00);
                                points.push({
                                    x: x * resolution,
                                    y: (y + t) * resolution
                                });
                            }

                            if (points.length === 2) {
                                ctx.moveTo(points[0].x, points[0].y);
                                ctx.lineTo(points[1].x, points[1].y);
                            }
                        }
                    }

                    ctx.stroke();
                }
            }
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // Event listeners
        contourCountSlider.addEventListener('input', () => {
            contourCount = parseInt(contourCountSlider.value);
            contourValue.textContent = contourCount;
            draw();
        });

        lineThicknessSlider.addEventListener('input', () => {
            lineThickness = parseInt(lineThicknessSlider.value);
            thicknessValue.textContent = lineThickness;
            draw();
        });

        flowScaleSlider.addEventListener('input', () => {
            flowScale = parseInt(flowScaleSlider.value);
            scaleValue.textContent = flowScale;
            draw();
        });

        turbulenceSlider.addEventListener('input', () => {
            turbulence = parseInt(turbulenceSlider.value);
            turbValue.textContent = turbulence;
            draw();
        });

        bgColorPicker.addEventListener('input', () => {
            bgColor = bgColorPicker.value;
            draw();
        });

        lineColorPicker.addEventListener('input', () => {
            lineColor = lineColorPicker.value;
            draw();
        });

        textColorPicker.addEventListener('input', () => {
            textOverlay.style.color = textColorPicker.value;
        });

        textInput.addEventListener('input', () => {
            textOverlay.textContent = textInput.value;
        });

        window.addEventListener('resize', () => {
            resizeCanvas();
            draw();
        });

        // Initial draw
        regenerate();
    </script>
</body>
</html>
